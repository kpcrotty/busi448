---
title: 'Optimal Portfolios: Borrowing Frictions'
author: "<br>Kevin Crotty<br>BUSI 448: Investments"
format: 
    revealjs:
        incremental: true
        logo: RiceLogo.png
        footer: "BUSI 448"
        self-contained: true
        code-fold: true
        theme: [default, custom.scss]
        show-slide-number: print
execute:
    echo: false
    freeze: auto
jupyter: python3
---
```{python}
#| echo: false
#| execute: true
import numpy as np
from cvxopt import matrix
from cvxopt.solvers import qp as Solver, options as SolverOptions
from scipy.optimize import minimize_scalar

SolverOptions["show_progress"] = False

class portfolio:
    def __init__(self, means, cov, Shorts):
        self.means = np.array(means)
        self.cov = np.array(cov)
        self.Shorts = Shorts
        self.n = len(means)
        if Shorts:
            w = np.linalg.solve(cov, np.ones(self.n))
            self.GMV = w / np.sum(w)
            w = np.linalg.solve(cov, means)
            self.piMu = w / np.sum(w)
        else:
            n = self.n
            Q = matrix(cov, tc="d")
            p = matrix(np.zeros(n), (n, 1), tc="d")
            G = matrix(-np.identity(n), tc="d")
            h = matrix(np.zeros(n), (n, 1), tc="d")
            A = matrix(np.ones(n), (1, n), tc="d")
            b = matrix([1], (1, 1), tc="d")
            sol = Solver(Q, p, G, h, A, b)
            self.GMV = np.array(sol["x"]).flatten() if sol["status"] == "optimal" else np.array(n * [np.nan])

    def frontier(self, m):
        if self.Shorts:
            gmv = self.GMV
            piMu = self.piMu
            m1 = gmv @ self.means
            m2 = piMu @ self.means
            a = (m - m2) / (m1 - m2)
            return a * gmv + (1 - a) * piMu
        else:
            n = self.n
            Q = matrix(self.cov, tc="d")
            p = matrix(np.zeros(n), (n, 1), tc="d")
            G = matrix(-np.identity(n), tc="d")
            h = matrix(np.zeros(n), (n, 1), tc="d")
            A = matrix(np.vstack((np.ones(n), self.means)), (2, n), tc="d")
            b = matrix([1, m], (2, 1), tc="d")
            sol = Solver(Q, p, G, h, A, b)
            return np.array(sol["x"]).flatten() if sol["status"] == "optimal" else np.array(n * [np.nan])

    def tangency(self, r):
        if self.Shorts:
            w = np.linalg.solve(self.cov, self.means - r)
            return w / np.sum(w)
        else:
            def f(m):
                w = self.frontier(m)
                mn = w @ self.means
                sd = np.sqrt(w.T @ self.cov @ w)
                return - (mn - r) / sd
            m = minimize_scalar(f, bounds=[max(r, np.min(self.means)), max(r, np.max(self.means))], method="bounded").x
            return self.frontier(m)

    def optimal(self, raver, rs=None, rb=None):
        n = self.n
        if self.Shorts:
            if (rs or rs==0) and (rb or rb==0):
                Q = np.zeros((n + 2, n + 2))
                Q[2:, 2:] = raver * self.cov
                Q = matrix(Q, tc="d")
                p = np.array([-rs, rb] + list(-self.means))
                p = matrix(p, (n + 2, 1), tc="d")
                G = np.zeros((2, n + 2))
                G[0, 0] = G[1, 1] = -1
                G = matrix(G, (2, n+2), tc="d")
                h = matrix([0, 0], (2, 1), tc="d")
                A = matrix([1, -1] + n*[1], (1, n+2), tc="d")
                b = matrix([1], (1, 1), tc="d")
                sol = Solver(Q, p, G, h, A, b)
                return np.array(sol["x"]).flatten()[2:] if sol["status"] == "optimal" else None
            else:
                w = np.linalg.solve(self.cov, self.means)
                a = np.sum(w)
                return (a/raver)*self.piMu + (1-a/raver)*self.GMV
        else:
           if (rs or rs==0) and (rb or rb==0):
                Q = np.zeros((n + 2, n + 2))
                Q[2:, 2:] = raver * self.cov
                Q = matrix(Q, tc="d")
                p = np.array([-rs, rb] + list(-self.means))
                p = matrix(p, (n+2, 1), tc="d")
                G = matrix(-np.identity(n + 2), tc="d")
                h = matrix(np.zeros(n+2), (n+2, 1), tc="d")
                A = matrix([1, -1] + n * [1], (1, n+2), tc="d")
                b = matrix([1], (1, 1), tc="d")
                sol = Solver(Q, p, G, h, A, b)
                return np.array(sol["x"]).flatten()[2:] if sol["status"] == "optimal" else None
           else:
                Q = matrix(raver * self.cov, tc="d")
                p = matrix(-self.means, (n, 1), tc="d")
                G = matrix(-np.identity(n), tc="d")
                h = matrix(np.zeros(n), (n, 1), tc="d")
                A = matrix(np.ones(n), (1, n), tc="d")
                b = matrix([1], (1, 1), tc="d")
                sol = Solver(Q, p, G, h, A, b)
                return np.array(sol["x"]).flatten() if sol["status"] == "optimal" else None
```

## Where are we?
**Last time**:

::: {.nonincremental}
- Capital Allocation: Risk-free + Risky
- Preferences over risk and return
- Optimal portfolios
:::

. . . 

**Today**:

::: {.nonincremental}
- Borrowing frictions
<!-- - Short-sales constraints -->
:::

# Borrowing frictions
## Leverage constraints

Many investors (like me!) cannot borrow at the same rate at which they can lend. \

In this case, the capital allocation line is not a straight line.

For most investors: 
$$r^{\text{borrow}}>r^{\text{saving}}$$

## Kinked Capital Allocation Lines

::: {.nonincremental}
- For portfolios with some risk-free saving:
$$ E[r_p] = r_f^{\text{saving}} + \bigg[ \frac{E[r_{\text{risky}}]-r_f^{\text{saving}}}{\text{sd}[r_{\text{risky}}] }\bigg]\cdot \text{sd}[r_p]\,.$$
:::

. . . 

::: {.nonincremental}
- For portfolios with borrowing, the capital allocation line has a lower slope:
$$ E[r_p] = r_f^{\text{borrow}} + \bigg[ \frac{E[r_{\text{risky}}]-r_f^{\text{borrow}}}{\text{sd}[r_{\text{risky}}] }\bigg]\cdot \text{sd}[r_p]\,.$$
:::

## Kinked Capital Allocation Lines 
```{python}
import numpy as np
import pandas as pd
import plotly.graph_objects as go

# Parameter values (in percent)
mn = 6
sd = 15
s = 2
extra = 1.25    #incremental borrowing rate

def data(mn, sd, s, b):
    grid = np.linspace(0, 2, 201)
    mns = [(s + w * (mn - s) if w <= 1 else b + w * (mn - b)) for w in grid]
    sds = [w * sd for w in grid]
    mns_infeasible = [(s + w * (mn - s) if w > 1 else b + w * (mn - b)) for w in grid]
    return grid, mns, sds, mns_infeasible

def figtbl(mn, sd, s, extra):
    mn /= 100
    sd /= 100
    b = s+extra
    s /= 100
    b /= 100
    grid, mns, sds, mns_infeasible = data(mn, sd, s, b)
    df = pd.DataFrame({'grid': grid, 'mns': mns, 'sds': sds, 'mns_infeas':mns_infeasible})
    string = "wealth in market = %{text:.0f}%<extra></extra>"
    trace1 = go.Scatter(
        x=df[grid<=1].sds, y=df[grid<=1].mns, mode="lines", text=100 * df[grid<=1].grid, hovertemplate=string, name='CAL (saving)', line=dict(color="blue"),
    )
    string = "wealth in market = %{text:.0f}%<extra></extra>"
    trace1a = go.Scatter(
        x=df[grid>1].sds, y=df[grid>1].mns, mode="lines", text=100 * df[grid>1].grid, hovertemplate=string, name='CAL (borrowing)', line=dict(color="blue"),
    )
    string = "infeasible saving at borrowing rate<extra></extra>"
    trace2 = go.Scatter(
        x=df[grid<=1].sds, y=df[grid<=1].mns_infeas, mode="lines", hovertemplate=string, showlegend = False, line=dict(color="black", dash='dot'),
    )
    string = "infeasible borrowing at saving rate<extra></extra>"
    trace2a = go.Scatter(
        x=df[grid>1].sds, y=df[grid>1].mns_infeas, mode="lines", hovertemplate=string, showlegend = False, line=dict(color="black", dash='dot'),
    )
    string = "wealth in market = 100%<extra></extra>"
    trace3 = go.Scatter(
        x=[sd], y=[mn], mode="markers", hovertemplate=string, marker=dict(size=15), name='Market'
    )
    string = "wealth in market = 0%<extra></extra>"
    trace4 = go.Scatter(
        x=[0], y=[s], mode="markers", hovertemplate=string, marker=dict(size=15), name='Risk-free (Saving)'
    )  
    string = "Borrowing rate<extra></extra>"
    trace5 = go.Scatter(
        x=[0], y=[b], mode="markers", hovertemplate=string, marker=dict(size=15), name='Risk-free (Borrowing)'
    )       
    fig = go.Figure()
    fig.add_trace(trace1)
    fig.add_trace(trace1a)
    fig.add_trace(trace2)
    fig.add_trace(trace2a)
    fig.add_trace(trace3)
    fig.add_trace(trace4)
    fig.add_trace(trace5)
    fig.layout.xaxis["title"] = "Standard Deviation"
    fig.layout.yaxis["title"] = "Expected Return"
    fig.update_yaxes(tickformat=".0%")
    fig.update_xaxes(tickformat=".0%")
    fig.update_layout(legend=dict(yanchor="top", y =0.99, xanchor="left", x=0.01))
    fig.show()
figtbl(mn, sd, s, extra)
```


## Optimal portfolios with leverage frictions

```{python}
import numpy as np
import pandas as pd
import plotly.graph_objects as go

mn_stock = 6
mn_bond  = 3.5
sd_stock = 15
sd_bond  = 3.5
corr = -5

rs = 2
extra = 1.25


def data(mn1, mn2, sd1, sd2, c, rs, extra):
    c = c / 100
    rb = rs + extra   
    rs = rs/100
    rb = rb/100
    mns = [mn1, mn2]
    sds = [sd1, sd2]
    grid = np.linspace(0, 1, 121)
    # grid = np.linspace(-0.2, 2, 121)
    ports = [np.array([w, 1 - w]) for w in grid]
    means = [p.T @ np.array(mns) for p in ports]
    df = pd.DataFrame(means)
    df.columns = ["mean"]
    cov = np.array(
        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]
    ).reshape(2, 2)
    df["stdev"] = [np.sqrt(p.T @ cov @ p) for p in ports]
    df["wt1"] = grid
    df["wt2"] = 1 - df.wt1
    for col in ["mean", "stdev"]:
        df[col] = df[col] / 100
    df["sr_s"]= (df["mean"] - rs)/df["stdev"]
    df["sr_b"]= (df["mean"] - rb)/df["stdev"]
   
    return df

def rf_plus_risky(mn, sd, rs, rb, w_min, w_max):
    mn /= 100
    sd /= 100
    rs /= 100
    rb /= 100
    grid = np.linspace(w_min, w_max, 201)
    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]
    sds = [w * sd for w in grid]
    srs = (mn - rs)/sd
    srb = (mn - rb)/sd
    return grid, mns, sds, srs, srb

def rf_plus_risky_nokink(mn, sd, rf, w_min, w_max):
    mn /= 100
    sd /= 100
    rf /= 100
    grid = np.linspace(w_min, w_max, 201)
    mns = [(rf + w * (mn - rf)) for w in grid]
    sds = [w * sd for w in grid]
    return grid, mns, sds


def figtbl(mn1, mn2, sd1, sd2, c, rs, extra, asset1_name, asset2_name):
    df = data(mn1, mn2, sd1, sd2, c, rs, extra)
    
    #Plot the portfolios of the two assets
    trace1 = go.Scatter(
        x=df["stdev"],
        y=df["mean"],
        mode="lines",
        # line={'color': green},
        text=100 * df["wt1"],
        customdata=100 * df["wt2"],
        hovertemplate=asset1_name+": %{text:.0f}%<br>"+asset2_name+": %{customdata:.0f}%<extra></extra>",
        line=dict(color="black"),
        name="Stock & Bond Frontier"
    )
    
    # Plot the two assets
    df = df[df.wt1.isin([0, 1])]
    df["text"] = np.where(df.wt1 == 1, asset1_name, asset2_name)
    trace2a = go.Scatter(
        x=df[df.wt1==1]["stdev"],
        y=df[df.wt1==1]["mean"],
        mode="markers",
        text=df[df.wt1==1]["text"],
        hovertemplate="%{text}<extra></extra>",
        marker=dict(size=10, color="orange"),
        name=asset1_name
    )
    trace2b = go.Scatter(
        x=df[df.wt1==0]["stdev"],
        y=df[df.wt1==0]["mean"],
        mode="markers",
        text=df[df.wt1==0]["text"],
        hovertemplate="%{text}<extra></extra>",
        marker=dict(size=10, color="red"),
        name=asset2_name
    )

    fig = go.Figure()
    fig.add_trace(trace2a)
    fig.add_trace(trace2b)
    fig.add_trace(trace1)

    # Plot the combination of the risk-free and each asset (CAL for each asset)
    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn1, sd1, rs, rs + extra, 0, 1.0)
    string = "wealth in "+asset1_name+"= %{text:.0f}%<br>" + "Sharpe ratio: " + "{:.4f}".format(srs_cal) +"<extra></extra>"
    trace3 = go.Scatter(
        x=sds_cal, 
        y=mns_cal, 
        mode="lines", 
        text=100 * grid, 
        hovertemplate=string, 
        line=dict(color="orange"),
        name="CAL: "+asset1_name
    )
    grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mn2, sd2, rs, rs + extra, 0, 1.0)
    string = "wealth in "+asset2_name+"= %{text:.0f}%<br>" + "Sharpe ratio : " + "{:.4f}".format(srs_cal) +"<extra></extra>"
    trace4 = go.Scatter(
        x=sds_cal, 
        y=mns_cal, 
        mode="lines", 
        text=100 * grid, 
        hovertemplate=string, 
        line=dict(color="red"),
        name="CAL: "+asset2_name
    )
    # fig.add_trace(trace3)
    # fig.add_trace(trace4)  


    def custom(string, ports,srTang,borrow_flag):
        # borrow_flag=1 adds statement about "relative to borrowing rate"
        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)
        for i in range(N):
            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)
        cd[:,N] = np.round(srTang,4)
        # print(cd)
        string += "<br>"
        for i in range(N):
            if i ==0:
                string += asset1_name
            elif i==1:
                string += asset2_name
            else:
                string += "asset " + str(i + 1)
            string += ": %{customdata["
            string += str(i)
            string += "]:.1%}<br>"
        if borrow_flag==1:
            string += "Sharpe ratio (relative to borrowing rate): %{customdata[" +  str(N) + "]:.4f}<br>"    
        else:
            string += "Sharpe ratio: %{customdata[" +  str(N) + "]:.4f}<br>"
        string += "<extra></extra>"
        return string, cd  

    # Plot the tangency portfolios
    c = c / 100
    rb = rs + extra     
    rs = rs/100
    rb = rb/100
    mns = [mn1, mn2]
    mns = np.array(mns) / 100
    sds = [sd1, sd2]
    sds = np.array(sds) / 100
    cov = np.array(
        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]
    ).reshape(2, 2)
    
    Shorts = True     
    N = len(mns)
    P = portfolio(mns, cov, Shorts)    
    gmv = P.GMV @ mns
    # print('GMV return is: ',gmv)
    if (rs < gmv) or (not Shorts):
        portTang = P.tangency(rs)
        mnTang = portTang @ mns
        if mnTang < np.max(mns):
            sdTang = np.sqrt(portTang @ cov @ portTang)
            srTang = (mnTang - rs)/sdTang
            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk' if rb != rs else 'tangency portfolio'
            string, cd = custom(string0, [portTang], srTang,0)
            trace = go.Scatter(
                x=[sdTang],
                y=[mnTang],
                mode="markers",
                customdata=cd,
                hovertemplate=string,
                marker=dict(size=10, color="blue"),
                name=string0
            )
            fig.add_trace(trace)
            
            #Plot CAL (no leverage)
            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,0, 1.0)
            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk' if rb != rs else 'tangency portfolio'
            string = "wealth in "+portlabel + " = %{text:.0f}%<br>" + "Sharpe ratio: " +  "{:.4f}".format(srTang) +"<extra></extra>"
            trace5 = go.Scatter(
                x=sds_cal, 
                y=mns_cal, 
                mode="lines", 
                text=100 * grid, 
                hovertemplate=string, 
                line=dict(color="blue"),
                name="CAL: " + portlabel
            )           
            fig.add_trace(trace5)
            
            #Plot CAL (with leverage)
            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rs*100,1.0, 1.5)
            trace5a = go.Scatter(
                x=sds_cal, 
                y=mns_cal, 
                mode="lines", 
                text=100 * grid, 
                hovertemplate=string, 
                line=dict(color="blue",dash='dot'),
                name="CAL: "  + portlabel + " (levered)"
                # showlegend=False
            )           
            # fig.add_trace(trace5a)         
            
            
            
            

    if (rb != rs) and ((gmv > rb) or (not Shorts)):
        portTang = P.tangency(rb)
        mnTang = portTang @ mns
        if mnTang < np.max(mns):
            sdTang = np.sqrt(portTang @ cov @ portTang)
            srTang = (mnTang - rb)/sdTang
            string = 'efficient high mean portfolio'
            string, cd = custom(string, [portTang], srTang,1)
            trace = go.Scatter(
                x=[sdTang],
                y=[mnTang],
                mode="markers",
                customdata=cd,
                hovertemplate=string,
                marker=dict(size=10, color="blue"),
                name="efficient high mean portfolio"
            )
            fig.add_trace(trace)
            
            #Plot CAL (with leverage)            
            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 1.0, 3.0)
            string = "wealth in efficient high mean = %{text:.0f}%<br>" + "Sharpe ratio (relative to borrowing rate): " + "{:.4f}".format(srTang) +"<extra></extra>"
            trace6 = go.Scatter(
                x=sds_cal, 
                y=mns_cal, 
                mode="lines", 
                text=100 * grid, 
                hovertemplate=string,
                line=dict(color="blue"),
                name = "CAL: efficient high mean"
            )           
            fig.add_trace(trace6)   
            
            #Plot CAL (without leverage) 
            grid, mns_cal, sds_cal = rf_plus_risky_nokink(mnTang*100, sdTang*100, rb*100, 0, 1)
            trace6a = go.Scatter(
                x=sds_cal, 
                y=mns_cal, 
                mode="lines", 
                text=100 * grid, 
                hovertemplate=string, 
                line=dict(color="blue", dash='dot'),
                name = "CAL: efficient high mean (unlevered)"
            )           
            # fig.add_trace(trace6a)      

    string = "Saving rate<extra></extra>"
    trace7 = go.Scatter(
        x=[0], y=[rs], mode="markers", hovertemplate=string, marker=dict(size=10, color="black"), name='Risk-free (Saving)'
    )
    fig.add_trace(trace7)     
    string = "Borrowing rate<extra></extra>"
    trace8 = go.Scatter(
        x=[0], y=[rb], mode="markers", hovertemplate=string, marker=dict(size=10, color="DarkGrey"), name='Risk-free (Borrowing)'
    )  
    fig.add_trace(trace8)   


    fig.layout.xaxis["title"] = "Standard Deviation"
    fig.layout.yaxis["title"] = "Expected Return"
    fig.update_xaxes(range=[-0.005, 1.25 * df["stdev"].max()])
    fig.update_yaxes(range=[0, 1.15 * df["mean"].max()])
    fig.update_yaxes(tickformat=".0%")
    fig.update_xaxes(tickformat=".0%")
    fig.update_layout(legend=dict(yanchor="top", y =0.65, xanchor="left", x=0.535))
    fig.show()
figtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,"Stock","Bond")
```


## Capital allocation with leverage frictions

- Where do investors with different risk aversions choose to invest when faced with this investment opportunity set?  

- The answer depends on the investor's risk aversion and the reward-risk ratios of the efficient low risk and high mean portfolios. 

## Capital allocation with leverage frictions

**High risk aversion investors** invest in the efficient low risk portfolio and save:
$$ w^*_{\text{low}} = \frac{E[r_{\text{low}}-r_f^{\text{saving}}]}{A \cdot \text{var}_{\text{low}}}.$$

. . .

**Low risk aversion investors** invest in the efficient high mean portfolio and borrow:
$$ w^*_{\text{high}} = \frac{E[r_{\text{high}}-r_f^{\text{borrow}}]}{A \cdot \text{var}_{\text{high}}}.$$


## Capital allocation with leverage frictions

**Intermediate risk aversion investors** invest in risky assets only.

- Can express as a two-asset portfolio of the efficient low and high risk portfolios.

- The optimal weight $a^*$ in the low-risk portfolio is: $$ a^* = \frac{E[r_{\text{low}} - r_{\text{high}}] - A (\text{cov}[r_{\text{low}}, r_{\text{high}}]-\text{var}[r_{\text{high}}])}{A (\text{var}[r_{\text{low}}]+\text{var}[r_{\text{high}}]-2\text{cov}[r_{\text{low}}, r_{\text{high}}])}\,,$$

- Note: $\text{cov}[r_{\text{low}}, r_{\text{high}}] = w_{\text{low}}' V w_{\text{high}}$, where $w_{\text{low}}$ and $w_{\text{high}}$ are the weights in the underlying risky assets for the efficient low-risk and high-mean portfolios, respectively.

## Capital allocation with leverage frictions
```{python}
import numpy as np
import pandas as pd
import plotly.graph_objects as go

mn_stock = 6
mn_bond  = 3.5
sd_stock = 15
sd_bond  = 3.5
corr = -5

rs = 2
extra = 1.25

raver1 = 2
raver2 = 5

def data(mn1, mn2, sd1, sd2, c, rs, extra):
    c = c / 100
    rb = rs + extra   
    rs = rs/100
    rb = rb/100
    mns = [mn1, mn2]
    sds = [sd1, sd2]
    grid = np.linspace(0, 1, 101)
    ports = [np.array([w, 1 - w]) for w in grid]
    means = [p.T @ np.array(mns) for p in ports]
    df = pd.DataFrame(means)
    df.columns = ["mean"]
    cov = np.array(
        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]
    ).reshape(2, 2)
    df["stdev"] = [np.sqrt(p.T @ cov @ p) for p in ports]
    df["wt1"] = grid
    df["wt2"] = 1 - df.wt1
    for col in ["mean", "stdev"]:
        df[col] = df[col] / 100
    df["sr_s"]= (df["mean"] - rs)/df["stdev"]
    df["sr_b"]= (df["mean"] - rb)/df["stdev"]
   
    return df

def rf_plus_risky(mn, sd, rs, rb, w_min, w_max):
    mn /= 100
    sd /= 100
    rs /= 100
    rb /= 100
    grid = np.linspace(w_min, w_max, 201)
    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]
    sds = [w * sd for w in grid]
    srs = (mn - rs)/sd
    srb = (mn - rb)/sd
    return grid, mns, sds, srs, srb

def opt_utility(mns, cov, Shorts, s, b, A):
    # P is a portfolio object based on expected returns, covariance matrix, and shorts
    P = portfolio(mns, cov, Shorts) 
    gmv = P.GMV @ mns
    if s==b:
        #tangency exp ret and sd
        if (s < gmv) or (not Shorts):
            portTang = P.tangency(s)
            mnTang = portTang @ mns
            if mnTang < np.max(mns):
                sdTang = np.sqrt(portTang @ cov @ portTang)

                #optimal weight in tangency based on risk-aversion
                wgt = (mnTang - s) / (A * (sdTang**2))
                expret= wgt*mnTang + (1-wgt)*s
                sdret = wgt*sdTang 
                wgt_rf = 1-wgt
                wgt_lo = wgt
                wgt_hi = 0.0
    else:
        #efficient low-risk portfolio
        if (s < gmv) or (not Shorts):
            portTangLowRisk = P.tangency(s)
            mnTangLowRisk = portTangLowRisk @ mns
            if mnTangLowRisk < np.max(mns):
                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)

        #efficient high-risk portfolio
        if ((b<gmv) or (not Shorts)):
            portTangHighRisk = P.tangency(b)
            mnTangHighRisk = portTangHighRisk @ mns
            if mnTangHighRisk < np.max(mns):
                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)

        #1st: efficient low risk CAL
        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))
        expret= wgt*mnTangLowRisk + (1-wgt)*s
        sdret = wgt*sdTangLowRisk 
        wgt_rf = 1-wgt
        wgt_lo = wgt
        wgt_hi = 0.0
        # print('Weight low risk CAL: ', wgt)
        if wgt > 1.0:
            #2nd: efficient high risk CAL
            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))
            expret= wgt*mnTangHighRisk + (1-wgt)*b
            sdret = wgt*sdTangHighRisk 
            wgt_rf = 1-wgt
            wgt_lo = 0.0
            wgt_hi = wgt
            # print('Weight high risk CAL: ', wgt)
            if wgt < 1.0:
                #3rd: risky asset frontier
                wgt = 1 #This is should be interpreted as total weight in risky assets.
                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios
                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk
                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))
                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk
                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)
                wgt_hi = 1-wgt_lo
                wgt_rf = 0.0

                # #Method 2: calculate frontier manually and choose max utility
                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)
                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))
                # for i,m in enumerate(eret_grid):
                #     portFrontier = P.frontier(m)
                #     df.loc[i,'mn'] = portFrontier @ mns
                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)
                # df['u']  = df['mn'] - 0.5*A* df['sd']**2
                # opt_mn = df.loc[df['u'].idxmax(),'mn']
                # portFrontier = P.frontier(opt_mn)
                # expret = portFrontier @ mns
                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)
                # print('Weight frontier: ', wgt)

    u = expret - 0.5*A*sdret**2
    return u, wgt, wgt_rf, wgt_lo, wgt_hi



def figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):
    df = data(mn1, mn2, sd1, sd2, c, rs, extra)
    
    #Plot the portfolios of the two assets
    trace1 = go.Scatter(
        x=df["stdev"],
        y=df["mean"],
        mode="lines",
        # line={'color': green},
        text=100 * df["wt1"],
        customdata=100 * df["wt2"],
        hovertemplate=asset1_name+": %{text:.0f}%<br>"+asset2_name+": %{customdata:.0f}%<extra></extra>",
        line=dict(color="black"),
        name="Stock & Bond Frontier"
    )
    
    # Plot the two assets
    df = df[df.wt1.isin([0, 1])]
    df["text"] = np.where(df.wt1 == 1, asset1_name, asset2_name)
    trace2a = go.Scatter(
        x=df[df.wt1==1]["stdev"],
        y=df[df.wt1==1]["mean"],
        mode="markers",
        text=df[df.wt1==1]["text"],
        hovertemplate="%{text}<extra></extra>",
        marker=dict(size=10, color="orange"),
        name=asset1_name
    )
    trace2b = go.Scatter(
        x=df[df.wt1==0]["stdev"],
        y=df[df.wt1==0]["mean"],
        mode="markers",
        text=df[df.wt1==0]["text"],
        hovertemplate="%{text}<extra></extra>",
        marker=dict(size=10, color="red"),
        name=asset2_name
    )

    fig = go.Figure()
    fig.add_trace(trace2a)
    fig.add_trace(trace2b)
    fig.add_trace(trace1)



    def custom(string, ports,srTang,borrow_flag):
        # borrow_flag=1 adds statement about "relative to borrowing rate"
        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)
        for i in range(N):
            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)
        cd[:,N] = np.round(srTang,4)
        # print(cd)
        string += "<br>"
        for i in range(N):
            string += "asset " + str(i + 1)
            string += ": %{customdata["
            string += str(i)
            string += "]:.1%}<br>"
        if borrow_flag==1:
            string += "Sharpe ratio (relative to borrowing rate): %{customdata[" +  str(N) + "]:.4f}<br>"    
        else:
            string += "Sharpe ratio: %{customdata[" +  str(N) + "]:.4f}<br>"
        string += "<extra></extra>"
        return string, cd  

    # Plot the tangency portfolios
    c = c / 100
    rb = rs + extra     
    rs = rs/100
    rb = rb/100
    mns = [mn1, mn2]
    mns = np.array(mns) / 100
    sds = [sd1, sd2]
    sds = np.array(sds) / 100
    cov = np.array(
        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]
    ).reshape(2, 2)
    
    Shorts = True    
    N = len(mns)
    P = portfolio(mns, cov, Shorts)    
    gmv = P.GMV @ mns
    # print('GMV return is: ',gmv)
    if (rs < gmv) or (not Shorts):
        portTang = P.tangency(rs)
        mnTang = portTang @ mns
        if mnTang < np.max(mns):
            sdTang = np.sqrt(portTang @ cov @ portTang)
            srTang = (mnTang - rs)/sdTang
            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'
            string, cd = custom(string0, [portTang], srTang,0)
            trace = go.Scatter(
                x=[sdTang],
                y=[mnTang],
                mode="markers",
                customdata=cd,
                hovertemplate=string,
                marker=dict(size=10, color="blue"),
                name=string0
            )
            fig.add_trace(trace)
            
            #Plot CAL (no leverage)
            if rb==rs:
                max_wgt = 4.0
            else:
                max_wgt = 1.0
            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)
            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'
            string = "wealth in "+portlabel + " = %{text:.0f}%<br>" + "Sharpe ratio: " +  "{:.4f}".format(srTang) +"<extra></extra>"
            trace5 = go.Scatter(
                x=sds_cal, 
                y=mns_cal, 
                mode="lines", 
                text=100 * grid, 
                hovertemplate=string, 
                line=dict(color="blue"),
                name="CAL: " + portlabel
            )           
            fig.add_trace(trace5)
              
            
            

    if (rb != rs) and ((gmv > rb) or (not Shorts)):
        portTang = P.tangency(rb)
        mnTang = portTang @ mns
        if mnTang < np.max(mns):
            sdTang = np.sqrt(portTang @ cov @ portTang)
            srTang = (mnTang - rb)/sdTang
            string = 'efficient high mean portfolio'
            string, cd = custom(string, [portTang], srTang,1)
            trace = go.Scatter(
                x=[sdTang],
                y=[mnTang],
                mode="markers",
                customdata=cd,
                hovertemplate=string,
                marker=dict(size=10, color="blue"),
                name="efficient high mean portfolio"
            )
            fig.add_trace(trace)
            
            #Plot CAL (with leverage)            
            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 4.0)
            string = "wealth in efficient high mean portfolio = %{text:.0f}%<br>" + "Sharpe ratio (relative to borrowing rate): " + "{:.4f}".format(srTang) +"<extra></extra>"
            trace6 = go.Scatter(
                x=sds_cal, 
                y=mns_cal, 
                mode="lines", 
                text=100 * grid, 
                hovertemplate=string,
                line=dict(color="blue"),
                name = "CAL: efficient high mean"
            )           
            fig.add_trace(trace6)   
 


    # Utility plot info
    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)
    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)
    string1='Risk Aversion='+str(raver1)
    string2='Risk Aversion='+str(raver2)
    grid = np.linspace(0,1.4,100)
    sds = [w*np.max(sds) for w in grid]
    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]
    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] 
    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})
    string = "indifference curve for <br> optimal utility for risk aversion of "+str(np.round(raver1,1))+"<extra></extra>"
    trace7 = go.Scatter(
        x=sds, y=eret1, mode="lines", hovertemplate=string, name=string1, line=dict(color="purple",dash='dot'),
    )  
    string = "indifference curve for <br> optimal utility for risk aversion of "+str(np.round(raver2,1))+"<extra></extra>"
    trace8 = go.Scatter(
        x=sds, y=eret2, mode="lines", hovertemplate=string, name=string2, line=dict(color="purple"),
    )  
    fig.add_trace(trace7) 
    fig.add_trace(trace8) 
 
    
    fig.layout.xaxis["title"] = "Standard Deviation"
    fig.layout.yaxis["title"] = "Expected Return"
    fig.update_xaxes(range=[0, 1.25 * df["stdev"].max()])
    fig.update_yaxes(range=[0, 1.25 * df["mean"].max()])
    fig.update_yaxes(tickformat=".0%")
    fig.update_xaxes(tickformat=".0%")
    fig.update_layout(legend=dict(yanchor="top", y =0.55, xanchor="left", x=0.6))
    fig.show()

figtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, "Stock","Bond")
```

## Risky asset allocation with leverage frictions
```{python}
#| echo: false
import numpy as np
import pandas as pd
import plotly.graph_objects as go

mn_stock = 6
mn_bond  = 3.5
sd_stock = 15
sd_bond  = 3.5
corr = -5

rs = 2
extra = 1.25

raver1 = 2
raver2 = 5

def data(mn1, mn2, sd1, sd2, c, rs, extra):
    c = c / 100
    rb = rs + extra   
    rs = rs/100
    rb = rb/100
    mns = [mn1, mn2]
    sds = [sd1, sd2]
    grid = np.linspace(-0.2, 1, 201)
    ports = [np.array([w, 1 - w]) for w in grid]
    means = [p.T @ np.array(mns) for p in ports]
    df = pd.DataFrame(means)
    df.columns = ["mean"]
    cov = np.array(
        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]
    ).reshape(2, 2)
    df["stdev"] = [np.sqrt(p.T @ cov @ p) for p in ports]
    df["wt1"] = grid
    df["wt2"] = 1 - df.wt1
    for col in ["mean", "stdev"]:
        df[col] = df[col] / 100
    df["sr_s"]= (df["mean"] - rs)/df["stdev"]
    df["sr_b"]= (df["mean"] - rb)/df["stdev"]
   
    return df

def rf_plus_risky(mn, sd, rs, rb, w_min, w_max):
    mn /= 100
    sd /= 100
    rs /= 100
    rb /= 100
    grid = np.linspace(w_min, w_max, 201)
    mns = [(rs + w * (mn - rs) if w <= 1 else rb + w * (mn - rb)) for w in grid]
    sds = [w * sd for w in grid]
    srs = (mn - rs)/sd
    srb = (mn - rb)/sd
    return grid, mns, sds, srs, srb

def opt_utility(mns, cov, Shorts, s, b, A):
    # P is a portfolio object based on expected returns, covariance matrix, and shorts
    P = portfolio(mns, cov, Shorts) 
    gmv = P.GMV @ mns
    if s==b:
        #tangency exp ret and sd
        if (s < gmv) or (not Shorts):
            portTang = P.tangency(s)
            mnTang = portTang @ mns
            if mnTang < np.max(mns):
                sdTang = np.sqrt(portTang @ cov @ portTang)

                #optimal weight in tangency based on risk-aversion
                wgt = (mnTang - s) / (A * (sdTang**2))
                expret= wgt*mnTang + (1-wgt)*s
                sdret = wgt*sdTang 
                wgt_rf = 1-wgt
                wgt_lo = wgt
                wgt_hi = 0.0
    else:
        #efficient low-risk portfolio
        if (s < gmv) or (not Shorts):
            portTangLowRisk = P.tangency(s)
            mnTangLowRisk = portTangLowRisk @ mns
            if mnTangLowRisk < np.max(mns):
                sdTangLowRisk = np.sqrt(portTangLowRisk @ cov @ portTangLowRisk)

        #efficient high-risk portfolio
        if ((b<gmv) or (not Shorts)):
            portTangHighRisk = P.tangency(b)
            mnTangHighRisk = portTangHighRisk @ mns
            if mnTangHighRisk < np.max(mns):
                sdTangHighRisk = np.sqrt(portTangHighRisk @ cov @ portTangHighRisk)

        #1st: efficient low risk CAL
        wgt = (mnTangLowRisk - s) / (A * (sdTangLowRisk**2))
        expret= wgt*mnTangLowRisk + (1-wgt)*s
        sdret = wgt*sdTangLowRisk 
        wgt_rf = 1-wgt
        wgt_lo = wgt
        wgt_hi = 0.0
        # print('Weight low risk CAL: ', wgt)
        if wgt > 1.0:
            #2nd: efficient high risk CAL
            wgt = (mnTangHighRisk - b) / (A * (sdTangHighRisk**2))
            expret= wgt*mnTangHighRisk + (1-wgt)*b
            sdret = wgt*sdTangHighRisk 
            wgt_rf = 1-wgt
            wgt_lo = 0.0
            wgt_hi = wgt
            # print('Weight high risk CAL: ', wgt)
            if wgt < 1.0:
                #3rd: risky asset frontier
                wgt = 1 #This is should be interpreted as total weight in risky assets.
                # Method 1: solve analytically for utility-maximizing mix of efficient low and high risk portfolios
                cov_hilo = portTangLowRisk.T @cov @ portTangHighRisk
                wgt_lo = (mnTangLowRisk - mnTangHighRisk - A *(cov_hilo  - sdTangHighRisk**2))/(A*(sdTangLowRisk**2 + sdTangHighRisk**2 - 2*cov_hilo))
                expret = wgt_lo*mnTangLowRisk + (1-wgt_lo)* mnTangHighRisk
                sdret = np.sqrt((wgt_lo**2) *sdTangLowRisk**2 + ((1-wgt_lo)**2) * sdTangHighRisk**2 + 2*wgt_lo*(1-wgt_lo)*portTangLowRisk.T @cov @ portTangHighRisk)
                wgt_hi = 1-wgt_lo
                wgt_rf = 0.0

                # #Method 2: calculate frontier manually and choose max utility
                # eret_grid = np.linspace(mnTangLowRisk, mnTangHighRisk, 100)
                # df = pd.DataFrame(dtype='float', columns=['mn','sd','u'],index=np.arange(0,100))
                # for i,m in enumerate(eret_grid):
                #     portFrontier = P.frontier(m)
                #     df.loc[i,'mn'] = portFrontier @ mns
                #     df.loc[i,'sd'] = np.sqrt(portFrontier @ cov @ portFrontier)
                # df['u']  = df['mn'] - 0.5*A* df['sd']**2
                # opt_mn = df.loc[df['u'].idxmax(),'mn']
                # portFrontier = P.frontier(opt_mn)
                # expret = portFrontier @ mns
                # sdret  = np.sqrt(portFrontier @ cov @ portFrontier)
                # print('Weight frontier: ', wgt)

    u = expret - 0.5*A*sdret**2
    return u, wgt, wgt_rf, wgt_lo, wgt_hi



def figtbl(mn1, mn2, sd1, sd2, c, rs, extra, raver1, raver2, asset1_name, asset2_name):
    df = data(mn1, mn2, sd1, sd2, c, rs, extra)
    
    #Plot the portfolios of the two assets
    trace1 = go.Scatter(
        x=df["stdev"],
        y=df["mean"],
        mode="lines",
        # line={'color': green},
        text=100 * df["wt1"],
        customdata=100 * df["wt2"],
        hovertemplate=asset1_name+": %{text:.0f}%<br>"+asset2_name+": %{customdata:.0f}%<extra></extra>",
        line=dict(color="black"),
        name="Stock & Bond Frontier"
    )
    
    # Plot the two assets
    df = df[df.wt1.isin([0, 1])]
    df["text"] = np.where(df.wt1 == 1, asset1_name, asset2_name)
    trace2a = go.Scatter(
        x=df[df.wt1==1]["stdev"],
        y=df[df.wt1==1]["mean"],
        mode="markers",
        text=df[df.wt1==1]["text"],
        hovertemplate="%{text}<extra></extra>",
        marker=dict(size=10, color="orange"),
        name=asset1_name
    )
    trace2b = go.Scatter(
        x=df[df.wt1==0]["stdev"],
        y=df[df.wt1==0]["mean"],
        mode="markers",
        text=df[df.wt1==0]["text"],
        hovertemplate="%{text}<extra></extra>",
        marker=dict(size=10, color="red"),
        name=asset2_name
    )

    fig = go.Figure()
    fig.add_trace(trace2a)
    fig.add_trace(trace2b)
    fig.add_trace(trace1)



    def custom(string, ports,srTang,borrow_flag):
        # borrow_flag=1 adds statement about "relative to borrowing rate"
        cd = np.empty(shape=(len(ports), N+1, 1), dtype=float)
        for i in range(N):
            cd[:, i] = np.array([w[i] for w in ports]).reshape(-1, 1)
        cd[:,N] = np.round(srTang,4)
        # print(cd)
        string += "<br>"
        for i in range(N):
            string += "asset " + str(i + 1)
            string += ": %{customdata["
            string += str(i)
            string += "]:.1%}<br>"
        if borrow_flag==1:
            string += "Sharpe ratio (relative to borrowing rate): %{customdata[" +  str(N) + "]:.4f}<br>"    
        else:
            string += "Sharpe ratio: %{customdata[" +  str(N) + "]:.4f}<br>"
        string += "<extra></extra>"
        return string, cd  

    # Plot the tangency portfolios
    c = c / 100
    rb = rs + extra     
    rs = rs/100
    rb = rb/100
    mns = [mn1, mn2]
    mns = np.array(mns) / 100
    sds = [sd1, sd2]
    sds = np.array(sds) / 100
    cov = np.array(
        [[sds[0] ** 2, sds[0] * sds[1] * c], [sds[0] * sds[1] * c, sds[1] ** 2]]
    ).reshape(2, 2)
    
    Shorts = 1.0     
    N = len(mns)
    P = portfolio(mns, cov, Shorts)    
    gmv = P.GMV @ mns
    # print('GMV return is: ',gmv)
    if (rs < gmv) or (not Shorts):
        portTang = P.tangency(rs)
        mnTang = portTang @ mns
        if mnTang < np.max(mns):
            sdTang = np.sqrt(portTang @ cov @ portTang)
            srTang = (mnTang - rs)/sdTang
            string0 = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'
            string, cd = custom(string0, [portTang], srTang,0)
            trace = go.Scatter(
                x=[sdTang],
                y=[mnTang],
                mode="markers",
                customdata=cd,
                hovertemplate=string,
                marker=dict(size=10, color="blue"),
                name=string0
            )
            fig.add_trace(trace)
            
            #Plot CAL (no leverage)
            if rb==rs:
                max_wgt = 4.0
            else:
                max_wgt = 1.0
            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100,0, max_wgt)
            portlabel = 'tangency portfolio' if rb == rs else 'efficient low risk portfolio' if rb != rs else 'tangency portfolio'
            string = "wealth in "+portlabel + " = %{text:.0f}%<br>" + "Sharpe ratio: " +  "{:.4f}".format(srTang) +"<extra></extra>"
            trace5 = go.Scatter(
                x=sds_cal, 
                y=mns_cal, 
                mode="lines", 
                text=100 * grid, 
                hovertemplate=string, 
                line=dict(color="blue"),
                name="CAL: " + portlabel
            )           
            fig.add_trace(trace5)
              
            
            

    if (rb != rs) and ((gmv > rb) or (not Shorts)):
        portTang = P.tangency(rb)
        mnTang = portTang @ mns
        if mnTang < np.max(mns):
            sdTang = np.sqrt(portTang @ cov @ portTang)
            srTang = (mnTang - rb)/sdTang
            string = 'efficient high mean portfolio'
            string, cd = custom(string, [portTang], srTang,1)
            trace = go.Scatter(
                x=[sdTang],
                y=[mnTang],
                mode="markers",
                customdata=cd,
                hovertemplate=string,
                marker=dict(size=10, color="blue"),
                name="efficient high mean portfolio"
            )
            fig.add_trace(trace)
            
            #Plot CAL (with leverage)            
            grid, mns_cal, sds_cal, srs_cal, srb_cal = rf_plus_risky(mnTang*100, sdTang*100, rs*100,rb*100, 1.0, 1.5)
            string = "wealth in efficient high mean portfolio = %{text:.0f}%<br>" + "Sharpe ratio (relative to borrowing rate): " + "{:.4f}".format(srTang) +"<extra></extra>"
            trace6 = go.Scatter(
                x=sds_cal, 
                y=mns_cal, 
                mode="lines", 
                text=100 * grid, 
                hovertemplate=string,
                line=dict(color="blue"),
                name = "CAL: efficient high mean"
            )           
            fig.add_trace(trace6)   
 




    # Utility plot info
    u1, wgt1, wgt_rf1, wgt_lo1, wgt_hi1 = opt_utility(mns, cov, Shorts, rs, rb, raver1)
    u2, wgt2, wgt_rf2, wgt_lo2, wgt_hi2 = opt_utility(mns, cov, Shorts, rs, rb, raver2)
    string1='Risk Aversion='+str(raver1)
    string2='Risk Aversion='+str(raver2)
    grid = np.linspace(0,1.4,100)
    sds = [w*np.max(sds) for w in grid]
    eret1 = [u1 + 0.5*raver1* (sd**2) for sd in sds]
    eret2 = [u2 + 0.5*raver2* (sd**2) for sd in sds] 
    # df = pd.DataFrame(data={'Standard Deviation': sds, string1: U1, string2: U2})
    string = "indifference curve for <br> optimal utility for risk aversion of "+str(np.round(raver1,1))+"<extra></extra>"
    trace7 = go.Scatter(
        x=sds, y=eret1, mode="lines", hovertemplate=string, name=string1, line=dict(color="purple",dash='dot'),
    )  
    string = "indifference curve for <br> optimal utility for risk aversion of "+str(np.round(raver2,1))+"<extra></extra>"
    trace8 = go.Scatter(
        x=sds, y=eret2, mode="lines", hovertemplate=string, name=string2, line=dict(color="purple"),
    )  
    fig.add_trace(trace7) 
    fig.add_trace(trace8) 
 
    
    fig.layout.xaxis["title"] = "Standard Deviation"
    fig.layout.yaxis["title"] = "Expected Return"
    fig.update_xaxes(range=[0, 1.25 * df["stdev"].max()])
    fig.update_yaxes(range=[0, 1.25 * df["mean"].max()])
    fig.update_yaxes(tickformat=".0%")
    fig.update_xaxes(tickformat=".0%")
    fig.update_layout(legend=dict(yanchor="top", y =0.99, xanchor="left", x=0.74))
    # fig.show()


    #2nd plot of risky asset share as function of risk aversion:
    ravers = np.arange(0.5,20,0.1)
    cd = np.empty(shape=(len(ravers),5,1),dtype=float)
    wgts = [opt_utility(mns, cov, Shorts, rs, rb, A) for A in ravers]
    df = pd.DataFrame(wgts, columns=['u','wgt_risky','wgt_rf','wgt_lowrisk','wgt_highrisk'])
    if (rb != rs):
        custdat = np.empty(shape=(df.shape[0],3,1), dtype=float)
        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)
        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)
        custdat[:,2] = np.array(100*df.wgt_highrisk).reshape(-1,1)
        string = 'risk-aversion: %{x:.1f}<br>'
        string+= 'risk-free: %{customdata[0]:.0f}%<br>'
        string+= 'efficient low risk: %{customdata[1]:.0f}%<br>'
        string+= 'efficient high mean: %{customdata[2]:.0f}%<br>'
        string+= '<extra></extra>'
        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color="orange"))
        fig = go.Figure()
        fig.add_trace(trace1)
    else:
        custdat = np.empty(shape=(df.shape[0],2,1), dtype=float)
        custdat[:,0] = np.array(100*df.wgt_rf).reshape(-1,1)
        custdat[:,1] = np.array(100*df.wgt_lowrisk).reshape(-1,1)
        string = 'risk-aversion: %{x:.1f}<br>'
        string+= 'risk-free: %{customdata[0]:.0f}%<br>'
        string+= 'tangency: %{customdata[1]:.0f}%<br>'
        string+= '<extra></extra>'
        trace1 = go.Scatter(x=ravers,y=df['wgt_risky'],mode='lines',customdata=custdat,hovertemplate=string, line=dict(color="orange"))
        fig = go.Figure()
        fig.add_trace(trace1)       
    fig.layout.xaxis["title"] = "Risk Aversion"
    fig.layout.yaxis["title"] = "Weight in Risky Assets"
    fig.update_yaxes(tickformat=".1%")
    fig.update_xaxes(tickformat=".2")
    fig.update_layout(legend=dict(yanchor="top", y =0.99, xanchor="left", x=0.74))
    fig.show()


figtbl(mn_stock,mn_bond,sd_stock,sd_bond,corr,rs,extra,raver1, raver2, "Stock","Bond")
```

## Capital allocation: two solution methods

- Method #1: Find risk aversion thresholds that represent low- and high-risk portfolios
- Method #2: Directly maximize mean-variance utility using all assets, including risk-free savings and borrowings

## Method #1: Risk aversion thresholds {.smaller}

We can find the risk aversion thresholds for savings and borrowing by setting risky asset allocation $w^* \le 1$ (savings) or $w^* \ge 1$ (borrowing) in the capital allocation expressions and solving for risk aversion.

- **Upper risk aversion threshold**: some savings if $$A \ge \frac{E[r_{\text{low}}-r_f]}{\text{var}(r_{\text{low}})}.$$

- **Lower risk aversion threshold**: some borrowing if $$A \le \frac{E[r_{\text{high}}-r_f]}{\text{var}(r_{\text{high}})}.$$

## Method #2: Direct optimization of utility {.smaller}

The optimal portfolio for investor with risk aversion $A$ solves:
$$ \underset{w_{\text{saving}},w_{\text{borrow}},w_1,w_2,\dots,w_N}{\text{max}} E[r_p] - 0.5 \cdot A \cdot \text{var}[r_p] $$ 
subject to the constraints $$w_{\text{saving}} + w_{\text{borrow}} + \sum_i w_i=1,$$ $$w_{\text{saving}} \ge 0,$$ $$w_{\text{borrow}} \le 0.$$ 

- We need to augment the expected return vector and covariance matrix with elements for the savings and borrowing assets.

## Mapping to `cvxopt.solvers.qp` {.smaller}
Recall the `cvxopt.solvers.qp` function's general form:
\begin{align*}
    \underset{w}{\text{min  }}& \frac{1}{2} w' Q w + p'w \\
     \text{subject to  } & Gw \le h \\
                        & Aw = b \\
\end{align*}

- $0.5w'Qw$ captures $0.5 \cdot A \cdot \text{var}[r_p]$
- $p'w$ captures $-E[r_p]$
- $Gw \le h$ captures only positive saving and negative borrowing
- $Aw=b$ is the fully invested constraint

## Python implementation
``` {.python code-line-numbers="|3-5|6-7|8-13|14-16"}
def opt_allocation2(means, cov, rf_save, rf_borrow, risk_aversion):
    n=len(means)
    Q = np.zeros((n + 2, n + 2))
    Q[2:, 2:] = risk_aversion * cov
    Q = matrix(Q, tc="d")
    p = np.array([-rf_save, -rf_borrow] + list(-means))
    p = matrix(p, (n + 2, 1), tc="d")
    # Constraint: saving weight positive, borrowing weight negative
    G = np.zeros((2, n + 2))
    G[0, 0] = -1
    G[1, 1] = 1
    G = matrix(G, (2, n+2), tc="d")
    h = matrix([0, 0], (2, 1), tc="d")
    # Constraint: fully-invested portfolio
    A = matrix(np.ones(n+2), (1, n+2), tc="d")
    b = matrix([1], (1, 1), tc="d")
    sol = Solver(Q, p, G, h, A, b)
    if sol["status"] == "optimal":
        wgts_optimal = np.array(sol["x"]).flatten()
    else:
        wgts_optimal = None
    return wgts_optimal
```

## Learn Investments Dashboard resources

[Optimal allocation with different rates](https://learn-investments.rice-business.org/portfolios/optimal-two-rates)
<!-- ## {background-iframe="http://bbcx-investments.com/portfolios/optimal-two-rates" background-interactive="True"} -->




# For next time: Short-sale constraints

<br><br><br><br>

![](RiceLogo.png){fig-align="center"}
